# 锁相关

1. ### ReentrantLock如何实现公平锁的

   1. ReentrantLock默认采用了非公平锁的策略来实现锁的竞争逻辑，其次，ReentrantLock内部使用了AQS来实现锁资源的竞争，没有竞争到锁资源的线程，会加入到AQS的同步队列里面，这个队列是一个FIFO的双向链表。在这样的一个背景下，公平锁的实现方式就是，线程在竞争锁资源的时候判断AQS同步队列里面有没有等待的线程。如果有，就加入到队列的尾部等待。而非公平锁的实现方式，就是不管队列里面有没有线程等待，它都会先去尝试抢占锁资源，如果抢不到，再加入到AQS同步队列等待。ReentrantLock和Synchronized默认都是非公平锁的策略，之所以要这么设计，我认为还是考虑到了性能这个方面的原因。如果是非公平策略，当前线程正好在上一个线程释放锁的临界点抢占到了锁，就意味着这个线程不需要切换到内核态，

2. volitale和synconized的区别是什么？

   1. `volatile` 关键字用于保证一个变量的可见性和禁止指令重排。在多线程环境下，当一个线程修改了一个 `volatile` 变量的值，其他线程可以立即看到这个变量的最新值，而不需要进行任何的同步操作。同时，使用 `volatile` 修饰的变量会禁止编译器和 CPU 对代码进行重排，保证了代码的正确性。

      `synchronized` 关键字则用于实现线程之间的互斥和同步。它可以用于修饰方法和代码块，当一个线程获取到某个对象的锁时，其他线程将无法访问该对象的锁修饰的方法或代码块，只有等待该线程释放锁之后才能继续执行。这样可以避免多线程环境下的数据竞争和并发问题。

      因此，`volatile` 和 `synchronized` 的作用和使用方式不同，`volatile` 主要用于保证变量的可见性和禁止指令重排，而 `synchronized` 主要用于实现线程之间的同步和互斥。

3. 
