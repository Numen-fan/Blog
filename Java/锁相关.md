# 锁相关

1. ### ReentrantLock如何实现公平锁的

   1. ReentrantLock默认采用了非公平锁的策略来实现锁的竞争逻辑，其次，ReentrantLock内部使用了AQS来实现锁资源的竞争，没有竞争到锁资源的线程，会加入到AQS的同步队列里面，这个队列是一个FIFO的双向链表。在这样的一个背景下，公平锁的实现方式就是，线程在竞争锁资源的时候判断AQS同步队列里面有没有等待的线程。如果有，就加入到队列的尾部等待。而非公平锁的实现方式，就是不管队列里面有没有线程等待，它都会先去尝试抢占锁资源，如果抢不到，再加入到AQS同步队列等待。ReentrantLock和Synchronized默认都是非公平锁的策略，之所以要这么设计，我认为还是考虑到了性能这个方面的原因。如果是非公平策略，当前线程正好在上一个线程释放锁的临界点抢占到了锁，就意味着这个线程不需要切换到内核态，

2. volitale和synconized的区别是什么？

   1. `volatile` 关键字用于保证一个变量的可见性和禁止指令重排。在多线程环境下，当一个线程修改了一个 `volatile` 变量的值，其他线程可以立即看到这个变量的最新值，而不需要进行任何的同步操作。同时，使用 `volatile` 修饰的变量会禁止编译器和 CPU 对代码进行重排，保证了代码的正确性。

      `synchronized` 关键字则用于实现线程之间的互斥和同步。它可以用于修饰方法和代码块，当一个线程获取到某个对象的锁时，其他线程将无法访问该对象的锁修饰的方法或代码块，只有等待该线程释放锁之后才能继续执行。这样可以避免多线程环境下的数据竞争和并发问题。

      因此，`volatile` 和 `synchronized` 的作用和使用方式不同，`volatile` 主要用于保证变量的可见性和禁止指令重排，而 `synchronized` 主要用于实现线程之间的同步和互斥。

3. AQS

   1. AQS（AbstractQueuedSynchronizer）是Java中的一个抽象类，提供了一种实现同步器的框架。它是Java并发包中许多同步器的基础，例如ReentrantLock、CountDownLatch、Semaphore等。

      AQS的实现是基于一个FIFO队列和一个state状态变量。队列中维护了等待锁的线程，state变量表示锁的状态。AQS提供了两种模式的同步器：独占模式和共享模式。独占模式表示只有一个线程可以获得锁，例如ReentrantLock；共享模式表示多个线程可以同时获得锁，例如Semaphore。

      AQS的主要方法是acquire()和release()，其中acquire()方法表示尝试获取锁，如果获取失败则加入等待队列，release()方法表示释放锁，并唤醒等待队列中的线程。

      除了acquire()和release()方法，AQS还提供了一些其他的方法，例如tryAcquire()和tryRelease()方法，它们用于在不需要阻塞线程的情况下尝试获取和释放锁。

      AQS的实现是基于模板方法设计模式，它定义了一些抽象方法，子类可以通过实现这些方法来实现自定义的同步器。这种设计模式使得AQS的实现具有很高的灵活性和可扩展性。

      总之，AQS是Java中实现同步器的一个基础框架，它提供了一个可靠、高效的同步机制，可以帮助开发者实现复杂的同步操作，从而保证多线程程序的正确性和稳定性。

4. JUC

   1. JUC是Java Util Concurrent的缩写，是Java中用于多线程编程的核心库。JUC库提供了许多并发编程的工具和框架，包括锁、并发集合、原子变量、线程池等等。下面简单介绍一下JUC中的一些重要的组件：

      1. Locks（锁）：JUC中提供了多种类型的锁，包括可重入锁（ReentrantLock）、读写锁（ReadWriteLock）、StampedLock等。这些锁可以帮助我们实现线程间的同步和协作。
      2. Concurrent Collections（并发集合）：JUC中提供了线程安全的集合类，包括ConcurrentHashMap、ConcurrentLinkedQueue、CopyOnWriteArrayList等等。这些集合类可以在多线程环境下安全地进行操作，避免了传统集合类在多线程环境下的线程安全问题。
      3. Atomic Variables（原子变量）：JUC中提供了原子变量类，包括AtomicInteger、AtomicLong、AtomicReference等等。这些原子变量可以保证在多线程环境下的操作是原子性的，避免了传统变量在多线程环境下的线程安全问题。
      4. Executors（线程池）：JUC中提供了Executor框架，可以帮助我们管理线程池。线程池可以帮助我们复用线程，避免了频繁地创建和销毁线程的开销，提高了系统的性能。

      总之，JUC是Java多线程编程中非常重要的组件之一，通过使用JUC提供的工具和框架，我们可以更加方便、高效、安全地进行多线程编程。

5. ConcurrentHashMap是基于CAS实现的线程安全集合。

6. HashMap和HashTable的区别

7. 悲观锁和乐观锁是两种常见的并发控制机制，用于解决并发环境下的数据访问问题。

   1. 悲观锁：

   悲观锁指的是对数据被并发访问的情况持悲观态度，因此每次访问数据时都会加锁，以避免其他线程对数据的并发访问。悲观锁的主要特点是独占锁，每次只允许一个线程访问共享数据，其他线程需要等待。悲观锁适用于并发量比较大的场景，例如数据库中的事务处理、银行系统中的转账操作等。

   1. 乐观锁：

   乐观锁指的是对数据被并发访问的情况持乐观态度，认为数据在大多数情况下不会有冲突，因此不会加锁，而是在更新数据时先检查数据是否被其他线程修改过，如果没有则直接更新，否则抛出并发更新异常。乐观锁的主要特点是乐观并发控制，多个线程可以同时访问共享数据，只有在更新时才会加锁。乐观锁适用于并发量较小，但冲突比较频繁的场景，例如社交网络中的点赞操作、商品库存的更新等。

   需要注意的是，悲观锁和乐观锁并不是完全独立的两种锁，而是两种思想的体现，实际应用中可以结合使用。例如在数据库中可以使用行级锁来实现悲观锁，同时在应用程序中使用版本号或时间戳等方式来实现乐观锁。

8. 可重入锁（Reentrant Lock）指的是支持重入的一种锁机制。所谓重入，是指在同一个线程中，可以重复获取同一把锁，而不会导致死锁或其他异常。

   在可重入锁中，每个锁关联一个获取计数器和一个所有者线程。当计数器为0时，锁被认为是未锁定状态；当某个线程请求一个未锁定的锁时，JVM将记录锁的拥有者，并且将获取计数器置为1。如果同一个线程再次请求这个锁，JVM将检查请求线程与记录的拥有者是否是同一个线程，如果是，则将获取计数器加1，然后返回。如果不是，则等待直到锁被释放为止。

   可重入锁的优点是避免了死锁，同时提供更大的灵活性和更细粒度的线程控制。可重入锁是Java中Lock接口的实现，使用Lock接口定义的锁机制可以通过lock()方法获得锁，通过unlock()方法释放锁，从而实现可重入锁的功能。与synchronized关键字相比，Lock接口提供了更多的特性，例如超时等待、非阻塞地获取锁、公平锁等。

9. 
