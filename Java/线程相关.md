# 线程相关

1. 线程池里面非核心线程什么时候会被回收?
   1. ThreadPoolExecutor回收工作线程，一条线程getTask()返回null，就会被回收。
2. 什么是线程安全
   1. 当多个线程访问某个类时，不管运行时环境采用 **何种调度方式** 或者这些进程将如何交替执行，并且在主调代码中**不需要任何额外的同步或协同**，这个类都能表现出**正确的行为**，那么就称这个类就是线程安全的。
3. 线程安全性的三个体现
   1. **原子性**：提供互斥访问，同一时刻只能有一个线程对数据进行操作（Atomic、CAS算法、synchronized、Lock）
   2. 可见性**：一个主内存的线程如果进行了修改，可以及时被其他线程观察到（synchronized、volatile）**
   3. 有序性**：如果两个线程不能从 **happens-before原则** 观察出来，那么就不能观察他们的有序性，虚拟机可以随意的对他们进行重排序，导致其观察观察结果杂乱无序（happens-before原则）
4. Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。 过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。通常我们最好也不 要使用Unsafe类，除非有明确的目的，并且也要对它有深入的了解才行。
5. CAS中ABA问题的解决

   CAS并非完美的，它会导致ABA问题，例如：当前内存的值一开始是A，被另外一个线程先改为B然后再改为A，那么当前线程访问的时候发现是A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。比如在链表中。 如何解决这个ABA问题呢，大多数情况下乐观锁的实现都会通过引入一个版本号标记这个对象，每次修改版本号都会变话，比如使用时间戳作为版本号，这样就可以很好的解决ABA问题。 在JDK中提供了`AtomicStampedReference`类来解决这个问题，这个类维护了一个int类型的标记stamp，每次更新数据的时候顺带更新一下stamp。

   
