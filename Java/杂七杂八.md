# 杂七杂八

1. 动态代理
   1. [廖雪峰关于动态代理的介绍](https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984)——没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，
2. 从本质上来说，Retrofit虽然只是一个RESTful 的HTTP 网络请求框架的封装库。但是，它内部通过 大量的设计模式 封装了 OkHttp，让使用者感到它非常简洁、易懂。它内部主要是用动态代理的方式，动态将网络请求接口的注解解析成HTTP请求，最后执行请求的过程。
3. 内存泄露的概念

   1. 内存泄漏指的是程序中分配的内存空间没有被及时地释放，导致这些内存空间一直被占用而没有被其他代码使用，最终会导致系统的内存耗尽。

      在 Java 中，内存泄漏通常指的是程序中存在一些不再被使用的对象，但由于某些原因（例如对象被错误地保留在缓存中、对象没有被正确地释放等），这些对象的内存空间无法被垃圾回收器回收，导致系统中存在大量无用的对象占用内存，最终导致内存溢出的问题。内存泄漏会严重影响程序的性能和稳定性，因此在程序开发中，我们应该尽可能地避免出现内存泄漏的情况。通常来说，避免内存泄漏的方法包括：

      1. 及时释放对象：在不再需要使用某个对象时，应该及时将其释放，并且确保所有的资源都被正确地释放。
      2. 使用弱引用或软引用：如果确实需要在程序中保留一些对象，但这些对象可能不会经常被使用，可以考虑使用弱引用或软引用来管理这些对象，从而避免内存泄漏。
      3. 避免创建过多的临时对象：在程序中，创建过多的临时对象会导致大量的内存分配和回收，因此应该尽可能地避免创建过多的临时对象。
      4. 定期检查内存使用情况：在程序开发和测试过程中，应该定期检
   2. 常见的内存泄露场景

      1. 持有对象引用过长：比如一个 Activity 持有了一个非静态的对象引用，在 Activity 销毁后，该对象引用依然存在导致对象无法被垃圾回收机制回收。
      2. 静态变量的滥用：静态变量的生命周期与应用程序相同，如果静态变量一直持有一个对象的引用，那么该对象也会一直存在内存中。
      3. 单例模式的滥用：如果单例模式中的对象长期存在，而没有被及时释放，也会导致内存泄漏。
4. 内部类问题

   1. 非静态内部类是不能声明静态成员的，无论是静态的变量还是静态方法；因为静态成员是在类加载的时候初始化，但是非静态内部类是在外部类new的过程中初始化的，即非静态内部类依赖外部类的存在而存在。

   1. 静态内部类不能访问外部类的非静态成员，这个和普通类中的静态与非静态成员之间的相互访问一致。

   1. 如果外部类和内部类有相同的成员，内部类想要访问外部类的成员时，需要加上OutClass.this#成员。

5. 

